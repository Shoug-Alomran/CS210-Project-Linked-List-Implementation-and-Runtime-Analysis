{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CS210 Project \u2014 Linked List Implementation &amp; Runtime Analysis","text":"<p>Welcome to the documentation site for the CS210 Project, developed by Shoug Alomran and Layan Bindayel Under the supervision of Dr. Najla Althuniyan</p> <p>This project evaluates how different sorting algorithms perform when applied to real-world student registration data stored in a custom Linked List structure.</p>"},{"location":"#project-overview","title":"Project Overview","text":""},{"location":"#custom-data-structure","title":"Custom Data Structure","text":"<p>Implementation of a fully functional Linked List to store and manage student registration records.</p>"},{"location":"#demand-scoring","title":"Demand Scoring","text":"<p>A weighted demand scoring system that evaluates registration priority using multiple factors.</p>"},{"location":"#sorting-algorithms","title":"Sorting Algorithms","text":"<p>Implementation and comparison of:</p> <ul> <li>Selection Sort  </li> <li>Insertion Sort  </li> <li>Merge Sort  </li> <li>Quick Sort  </li> </ul>"},{"location":"#runtime-analysis","title":"Runtime Analysis","text":"<p>Measurement and benchmarking of execution times to compare theoretical vs. practical performance.</p>"},{"location":"#key-objectives","title":"Key Objectives","text":"<ul> <li> <p>Build a fully functional program that reads,     processes, and sorts real registration data.</p> </li> <li> <p>Compare theoretical complexity (Big-O)     with measured runtime performance.</p> </li> <li> <p>Analyze how algorithm design impacts scalability.</p> </li> <li> <p>Present clear, structured documentation     for both implementation and analysis.</p> </li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li> <p>Introduction     Background, problem statement, and scope.</p> </li> <li> <p>System Design Overview     Major components and execution flow.</p> </li> <li> <p>Asymptotic Analysis     Theoretical T(n) and O(n) complexity comparison.</p> </li> <li> <p>Runtime Measurement     Empirical performance evaluation.</p> </li> <li> <p>Teamwork     Task distribution and coordination.</p> </li> <li> <p>Conclusion     Findings and future recommendations.</p> </li> <li> <p>References     Academic and technical sources.</p> </li> <li> <p>Appendices     Flowcharts, screenshots, and source code.</p> </li> </ul>"},{"location":"#technologies-used","title":"Technologies Used","text":"<ul> <li>Language: Java  </li> <li>Environment: Visual Studio Code  </li> <li>Documentation: MkDocs Material  </li> <li>Version Control: GitHub  </li> </ul>"},{"location":"#repository","title":"Repository","text":"<p>You can view the complete project source code and documentation:</p> <p>CS210 Project Repository</p>"},{"location":"#summary","title":"Summary","text":"<p>This project integrates theoretical foundations with practical implementation. It demonstrates how runtime analysis reflects algorithmic efficiency and highlights the relationship between Linked Lists, sorting algorithms, and performance optimization in computational problem-solving.</p>"},{"location":"conclusion/","title":"Conclusion","text":"<p>The results confirm that the implemented algorithms behaved as predicted both theoretically and empirically.</p> <p>Runtime measurements showed that:</p> <ul> <li> <p>Merge Sort and Quick Sort achieved the fastest execution times   due to their O(n log n) complexity.</p> </li> <li> <p>Selection Sort and Insertion Sort performed significantly slower,   consistent with their O(n\u00b2) time complexity.</p> </li> </ul> <p>The close alignment between theoretical analysis and measured results demonstrates correctness of implementation and validity of benchmarking.</p>"},{"location":"conclusion/#lessons-learned","title":"Lessons Learned","text":""},{"location":"conclusion/#simplicity-vs-efficiency","title":"Simplicity vs. Efficiency","text":"<p>Simple algorithms such as Selection Sort and Insertion Sort are easier to implement and understand but do not scale well.</p>"},{"location":"conclusion/#scalability-matters","title":"Scalability Matters","text":"<p>Advanced algorithms like Merge Sort and Quick Sort, while more complex, provide significantly better performance for large datasets.</p>"},{"location":"conclusion/#theory-meets-practice","title":"Theory Meets Practice","text":"<p>This project reinforced how theoretical complexity directly impacts measurable runtime in real-world scenarios.</p>"},{"location":"conclusion/#future-recommendations","title":"Future Recommendations","text":""},{"location":"conclusion/#real-time-integration","title":"Real-Time Integration","text":"<p>Process live registration data directly from a university database.</p>"},{"location":"conclusion/#visualization-interface","title":"Visualization Interface","text":"<p>Implement a graphical interface to visualize demand scores and sorted results dynamically.</p>"},{"location":"conclusion/#advanced-validation","title":"Advanced Validation","text":"<p>Add automated data validation and stronger input error detection.</p>"},{"location":"conclusion/#broader-algorithm-comparison","title":"Broader Algorithm Comparison","text":"<p>Extend analysis to include algorithms such as Heap Sort and Counting Sort.</p>"},{"location":"conclusion/#final-reflection","title":"Final Reflection","text":"<p>This project successfully demonstrated the relationship between data structures, algorithm design, and runtime efficiency.</p> <p>It highlights how thoughtful algorithm selection directly influences system scalability and performance in practical software development.</p>"},{"location":"copyright/","title":"Copyright &amp; Usage Policy","text":"<p>\u00a9 2026 Shoug Fawaz Alomran All rights reserved.</p> <p>All content published under this domain and its subdomains \u2014 including software projects, source code, documentation, designs, research, and written material \u2014 is protected under applicable international copyright laws.</p>"},{"location":"copyright/#permitted-use","title":"Permitted Use","text":"<ul> <li> <p>Viewing and referencing for personal, educational,     and non-commercial purposes.</p> </li> <li> <p>Quoting limited portions of content with     proper attribution.</p> </li> </ul>"},{"location":"copyright/#prohibited-use","title":"Prohibited Use","text":"<ul> <li> <p>Reproduction or redistribution of full projects     without permission.</p> </li> <li> <p>Commercial use of any content without written authorization.</p> </li> <li> <p>Claiming authorship or misrepresenting ownership     of this work.</p> </li> </ul>"},{"location":"copyright/#licensing","title":"Licensing","text":"<p>Specific projects may include individual license terms (e.g., open-source licenses).</p> <p>In the event of a conflict, the project-level license takes precedence over this general policy.</p>"},{"location":"copyright/#contact","title":"Contact","text":"<p>For permission requests or licensing inquiries:</p> <p>Shoug.Alomran@Shoug-Tech.com</p>"},{"location":"references/","title":"References &amp; Resources","text":"<p>The following academic and technical sources supported the algorithm analysis, implementation decisions, and theoretical validation of this project.</p>"},{"location":"references/#academic-textbooks","title":"Academic Textbooks","text":"<ul> <li> <p>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2022). Introduction to Algorithms (4th ed.). MIT Press.     Comprehensive reference for sorting algorithms,     asymptotic analysis, and Big-O notation.</p> </li> <li> <p>Weiss, M. A. (2014). Data Structures and Algorithm Analysis in Java (3rd ed.). Pearson Education.     Detailed discussion of Linked Lists and sorting implementations in Java.</p> </li> <li> <p>Sedgewick, R., &amp; Wayne, K. (2011). Algorithms (4th ed.). Addison-Wesley.     Provides mathematical foundations and visual explanations     of sorting algorithms.</p> </li> </ul>"},{"location":"references/#online-technical-resources","title":"Online Technical Resources","text":"<ul> <li> <p>GeeksforGeeks. (n.d.). Sorting Algorithms \u2013 Complete Guide.     Retrieved October 2025 from:     https://www.geeksforgeeks.org/sorting-algorithms/     Practical examples and complexity breakdowns.</p> </li> <li> <p>TutorialsPoint. (n.d.). Data Structures and Algorithms \u2013 Sorting Techniques.     Retrieved October 2025 from:     https://www.tutorialspoint.com/data_structures_algorithms/sorting_algorithms.htm     Algorithm overviews and pseudocode explanations.</p> </li> </ul>"},{"location":"references/#project-repository","title":"Project Repository","text":"<ul> <li> <p>Alomran, S., &amp; Bindayel, L. (2025). CS210 Project \u2013 Linked List Implementation and Runtime Analysis     [Computer software]. GitHub.  </p> <p>Repository: https://github.com/Shoug-Alomran/CS210-Project-Linked-List-Implementation-and-Runtime-Analysis</p> </li> </ul>"},{"location":"analysis/asymptotic-complexity/","title":"Asymptotic Complexity","text":"<p>This section evaluates the theoretical time complexity T(n) and asymptotic growth rate O(n) for each phase of the system.</p> <p>Asymptotic analysis allows us to predict how performance scales as the dataset size increases.</p>"},{"location":"analysis/asymptotic-complexity/#file-reading-writing","title":"File Reading &amp; Writing","text":"<ul> <li>Operation: Reading from <code>Input.txt</code> </li> <li>Operation: Writing to <code>Output.txt</code> </li> <li> <p>Time Complexity: O(n)</p> <p>Each record is processed exactly once. The total number of operations grows linearly with the number of registration records.</p> </li> </ul>"},{"location":"analysis/asymptotic-complexity/#demand-score-calculation","title":"Demand Score Calculation","text":"<ul> <li>Operation: Compute demand score per registration  </li> <li> <p>Time Complexity: O(n)</p> <p>Each student record is evaluated once using constant-time arithmetic and conditional logic. No nested iteration is involved.</p> </li> </ul>"},{"location":"analysis/asymptotic-complexity/#sorting-algorithms-complexity","title":"Sorting Algorithms Complexity","text":"Algorithm Best Case Average Case Worst Case Explanation Selection Sort O(n\u00b2) O(n\u00b2) O(n\u00b2) Repeatedly scans remaining unsorted elements to find minimum. Insertion Sort O(n) O(n\u00b2) O(n\u00b2) Efficient for nearly sorted data; degrades with disorder. Merge Sort O(n log n) O(n log n) O(n log n) Recursively divides array and merges efficiently. Quick Sort O(n log n) O(n log n) O(n\u00b2) Efficient with balanced pivots; worst case occurs with poor pivot choice."},{"location":"analysis/asymptotic-complexity/#theoretical-insights","title":"Theoretical Insights","text":""},{"location":"analysis/asymptotic-complexity/#linear-phases","title":"Linear Phases","text":"<p>File operations and demand score computation scale proportionally with input size (O(n)).</p>"},{"location":"analysis/asymptotic-complexity/#divide-and-conquer-efficiency","title":"Divide-and-Conquer Efficiency","text":"<p>Merge Sort and Quick Sort reduce the problem size recursively, achieving O(n log n) growth.</p>"},{"location":"analysis/asymptotic-complexity/#quadratic-growth","title":"Quadratic Growth","text":"<p>Selection and Insertion Sort require nested iteration, resulting in O(n\u00b2) scaling for larger datasets.</p>"},{"location":"analysis/asymptotic-complexity/#summary","title":"Summary","text":"<p>Theoretical analysis confirms that:</p> <ul> <li>Merge Sort and Quick Sort are optimal for large datasets.</li> <li>Selection Sort and Insertion Sort are simpler but inefficient at scale.</li> <li>Linear operations (file I/O and scoring) do not dominate runtime.</li> </ul> <p>This theoretical framework directly explains the empirical runtime measurements observed in the system.</p>"},{"location":"analysis/interpretation/","title":"Interpretation of Results","text":"<p>The empirical runtime data and theoretical complexity analysis demonstrate strong alignment between predicted and observed behavior for all implemented sorting algorithms.</p>"},{"location":"analysis/interpretation/#key-observations","title":"Key Observations","text":""},{"location":"analysis/interpretation/#superior-performance","title":"Superior Performance","text":"<p>Merge Sort and Quick Sort consistently outperformed the other algorithms due to their O(n log n) time complexity.</p>"},{"location":"analysis/interpretation/#quadratic-growth","title":"Quadratic Growth","text":"<p>Insertion Sort and Selection Sort exhibited noticeable runtime growth, consistent with O(n\u00b2) complexity.</p>"},{"location":"analysis/interpretation/#theory-validated","title":"Theory Validated","text":"<p>The measured runtimes closely matched theoretical expectations, validating both the correctness of implementation and the reliability of benchmarking.</p>"},{"location":"analysis/interpretation/#insights-lessons-learned","title":"Insights &amp; Lessons Learned","text":""},{"location":"analysis/interpretation/#simplicity-vs-efficiency","title":"Simplicity vs. Efficiency","text":"<p>Simpler algorithms (Selection and Insertion Sort) are easier to implement and reason about, but do not scale efficiently as data size increases.</p>"},{"location":"analysis/interpretation/#scalability-matters","title":"Scalability Matters","text":"<p>Divide-and-conquer algorithms (Merge and Quick Sort) maintain significantly better growth behavior, making them suitable for large datasets.</p>"},{"location":"analysis/interpretation/#system-level-optimization","title":"System-Level Optimization","text":"<p>Efficient file handling, structured scoring logic, and a modular linked-list implementation contributed to stable and predictable performance.</p>"},{"location":"analysis/interpretation/#overall-interpretation","title":"Overall Interpretation","text":"<p>This project reinforces a fundamental principle in algorithm design:</p> <p>Theoretical complexity directly influences practical runtime behavior.</p> <p>The results demonstrate how informed algorithm selection significantly impacts scalability, efficiency, and system performance in real-world applications.</p>"},{"location":"analysis/runtime-measurement/","title":"Runtime Measurement","text":"<p>Runtime performance was measured using the Java Clock class to capture execution time for each major phase.</p> <p>The dataset contained 3432 registration records, and all algorithms were executed under identical system conditions to ensure fairness and consistency.</p>"},{"location":"analysis/runtime-measurement/#measured-runtime-results","title":"Measured Runtime Results","text":"Operation Theoretical Complexity Actual Runtime (ms) File Reading O(n) 106 Demand Score Calculation O(n) 98 File Writing (Unsorted) O(n) 48 Selection Sort O(n\u00b2) 45 Insertion Sort O(n\u00b2) 26 Merge Sort O(n log n) 17 Quick Sort O(n log n) 22"},{"location":"analysis/runtime-measurement/#performance-analysis","title":"Performance Analysis","text":""},{"location":"analysis/runtime-measurement/#best-performing-algorithms","title":"Best Performing Algorithms","text":"<p>Merge Sort (17 ms) achieved the fastest runtime, followed closely by Quick Sort (22 ms).</p> <p>Their performance aligns with their O(n log n) time complexity.</p>"},{"location":"analysis/runtime-measurement/#quadratic-algorithms","title":"Quadratic Algorithms","text":"<p>Selection Sort (45 ms) and Insertion Sort (26 ms) showed slower performance, consistent with O(n\u00b2) behavior.</p>"},{"location":"analysis/runtime-measurement/#linear-operations","title":"Linear Operations","text":"<p>File reading, writing, and demand score computation scaled linearly with input size, validating their O(n) complexity.</p>"},{"location":"analysis/runtime-measurement/#observations","title":"Observations","text":"<ul> <li>The measured results closely match theoretical expectations.</li> <li>The gap between O(n\u00b2) and O(n log n) becomes more significant   as dataset size increases.</li> <li>Merge Sort demonstrated slightly better consistency than Quick Sort   under this dataset.</li> <li>File I/O overhead remains predictable and linear.</li> </ul>"},{"location":"analysis/runtime-measurement/#validation-statement","title":"Validation Statement","text":"<p>The close alignment between theoretical complexity and empirical runtime measurement confirms:</p> <ul> <li>Correct algorithm implementation  </li> <li>Accurate benchmarking methodology  </li> <li>Valid performance comparison  </li> </ul> <p>This reinforces the practical importance of algorithm selection in scalable software design.</p>"},{"location":"appendix/flowchart/","title":"Appendix A \u2014 System Flowchart","text":"<p>This appendix presents the overall system workflow, from input validation to runtime benchmarking and output generation.</p>"},{"location":"appendix/flowchart/#system-execution-flow","title":"System Execution Flow","text":""},{"location":"appendix/flowchart/#program-start","title":"Program Start","text":"<p>Initialize execution and prepare runtime measurement.</p>"},{"location":"appendix/flowchart/#data-reading-validation","title":"Data Reading &amp; Validation","text":"<p>Read records from <code>Input.txt</code> and validate structure using InputValidator.java.</p>"},{"location":"appendix/flowchart/#data-storage","title":"Data Storage","text":"<p>Store valid records in a custom Linked List implemented in <code>LinkedList.java</code>.</p>"},{"location":"appendix/flowchart/#demand-score-calculation","title":"Demand Score Calculation","text":"<p>Compute demand score based on: - Base score - Academic level multiplier - Registration time - Course ID priority  </p> <p>Implemented in DemandScorer.java.</p>"},{"location":"appendix/flowchart/#data-conversion","title":"Data Conversion","text":"<p>Convert the Linked List into an array to prepare for sorting.</p>"},{"location":"appendix/flowchart/#sorting-benchmarking","title":"Sorting &amp; Benchmarking","text":"<p>Apply: - Selection Sort - Insertion Sort - Merge Sort - Quick Sort  </p> <p>Measure runtime using Benchmarker.java and Timer.java.</p>"},{"location":"appendix/flowchart/#output-generation","title":"Output Generation","text":"<p>Write processed results to <code>Output.txt</code> and generate sorted output files.</p>"},{"location":"appendix/flowchart/#runtime-summary","title":"Runtime Summary","text":"<p>Display performance comparison and terminate program.</p>"},{"location":"appendix/flowchart/#system-flowchart-diagram","title":"System Flowchart Diagram","text":"View Flowchart <p>Figure: Flowchart illustrating the complete system process for course registration analysis.</p>"},{"location":"appendix/flowchart/#class-responsibility-mapping","title":"Class Responsibility Mapping","text":"<p>The following Java classes correspond to the flow stages:</p> <ul> <li>InputValidator.java \u2192 Data validation  </li> <li>LinkedList.java \u2192 Data storage and traversal  </li> <li>DemandScorer.java \u2192 Demand score computation  </li> <li>Sorting Classes \u2192 Algorithm implementation  </li> <li>Benchmarker.java / Timer.java \u2192 Runtime measurement  </li> </ul> <p>This modular architecture ensures:</p> <ul> <li>Clear separation of concerns  </li> <li>Reusability of components  </li> <li>Simplified debugging and testing  </li> <li>Scalability for future enhancements  </li> </ul>"},{"location":"appendix/full-code/","title":"Appendix B \u2014 Full Source Code","text":"<p>This appendix includes the complete Java implementation used in the CS210 Project \u2014 Linked List Implementation and Runtime Analysis.</p> <p>All files were developed in Visual Studio Code (VS Code) and compiled using Java 17.</p> <p>Each file plays a defined role within the system\u2019s modular architecture.</p>"},{"location":"appendix/full-code/#1-core-data-structures","title":"1. Core Data Structures","text":"Node.java \u2014 Linked List Node Structure <pre><code>public class Node {\n    Registration studData;\n    Node next;\n\n    public Node(Registration studData) {\n        this.studData = studData;\n        this.next = null;\n    }\n}\n</code></pre> Registration.java \u2014 Data Model <pre><code>public class Registration {\n    private String studentID;\n    private String courseID;\n    private int academicLevel;\n    private int studTime;\n    private double studDemandScore;\n\n    public Registration(String studentID, String courseID, int academicLevel, int studTime, double studDemandScore) {\n        this.studentID = studentID;\n        this.courseID = courseID;\n        this.academicLevel = academicLevel;\n        this.studTime = studTime;\n        this.studDemandScore = 0;\n    }\n\n    public String getStudentID() { return studentID; }\n    public String getCourseID() { return courseID; }\n    public int getAcademicLevel() { return academicLevel; }\n    public int getStudTime() { return studTime; }\n    public double getStudDemandScore() { return studDemandScore; }\n\n    public void setStudDemandScore(double studDemandScore) {\n        this.studDemandScore = studDemandScore;\n    }\n\n    @Override\n    public String toString() {\n        return studentID + \";\" + courseID + \";\" + academicLevel + \";\" + studTime + \";\" + Math.round(studDemandScore) + \";\";\n    }\n}\n</code></pre>"},{"location":"appendix/full-code/#2-linked-list-implementation","title":"2. Linked List Implementation","text":"LinkedList.java \u2014 Custom Implementation <pre><code>public class LinkedList {\n    Node head;\n    Node tail;\n    int size;\n\n    public void insertNodeAtTail(Registration data) {\n        Node newNode = new Node(data);\n        if (head == null) {\n            head = tail = newNode;\n        } else {\n            tail.next = newNode;\n            tail = newNode;\n        }\n        size++;\n    }\n\n    public Registration[] convToArray() {\n        Registration[] array = new Registration[size];\n        Node temp = head;\n        int i = 0;\n        while (temp != null) {\n            array[i++] = temp.studData;\n            temp = temp.next;\n        }\n        return array;\n    }\n}\n</code></pre>"},{"location":"appendix/full-code/#3-supporting-classes","title":"3. Supporting Classes","text":"FileService.java \u2014 File Handling Layer <pre><code>import java.io.*;\n\npublic class FileService {\n    public static LinkedList readRegistrationsFromFile(String filename) {\n        return InputValidator.readAndValidateFile(filename);\n    }\n}\n</code></pre> InputValidator.java \u2014 Input Processing <pre><code>import java.io.*;\n\npublic class InputValidator {\n    public static LinkedList readAndValidateFile(String filename) {\n        LinkedList list = new LinkedList();\n        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                String[] parts = line.split(\";\");\n                if (parts.length == 4) {\n                    list.insertNodeAtTail(\n                        new Registration(\n                            parts[0],\n                            parts[1],\n                            Integer.parseInt(parts[2]),\n                            Integer.parseInt(parts[3]),\n                            0\n                        )\n                    );\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error reading file: \" + e.getMessage());\n        }\n        return list;\n    }\n}\n</code></pre> DemandScorer.java \u2014 Demand Calculation Logic <pre><code>public class DemandScorer {\n    public static void calculateScores(LinkedList list) {\n        Node current = list.head;\n        while (current != null) {\n            Registration reg = current.studData;\n            double score = 50;\n\n            switch (reg.getAcademicLevel()) {\n                case 1 -&gt; score *= 0.75;\n                case 2 -&gt; score *= 0.90;\n                case 3 -&gt; score *= 1.10;\n                case 4 -&gt; score *= 1.25;\n                case 5 -&gt; score *= 1.50;\n            }\n\n            int t = reg.getStudTime();\n            if (t &gt;= 6 &amp;&amp; t &lt; 8) score += 5;\n            else if (t &gt;= 8 &amp;&amp; t &lt; 10) score += 10;\n            else if (t &gt;= 14 &amp;&amp; t &lt; 16) score -= 5;\n            else if (t &gt;= 16 &amp;&amp; t &lt; 20) score -= 10;\n            else if (t &gt;= 20) score -= 15;\n\n            if (reg.getCourseID().endsWith(\"1\") ||\n                reg.getCourseID().endsWith(\"3\") ||\n                reg.getCourseID().endsWith(\"5\"))\n                score += 20;\n            else\n                score -= 10;\n\n            reg.setStudDemandScore(score);\n            current = current.next;\n        }\n    }\n}\n</code></pre>"},{"location":"appendix/run-screenshots/","title":"Appendix C \u2014 Runtime Output Screenshots","text":"<p>This appendix presents runtime screenshots captured during execution of the CS210 Project \u2014 Student Course Registration Analysis.</p> <p>Each screenshot documents a specific stage of program execution, from input validation to sorting performance benchmarking.</p>"},{"location":"appendix/run-screenshots/#1-full-run-validation","title":"1. Full Run Validation","text":"View Screenshot \u2014 Full Run Validation <p>Displays validation of input data and confirmation that 3432 registration records were successfully read.</p> <p></p>"},{"location":"appendix/run-screenshots/#2-full-program-run","title":"2. Full Program Run","text":"View Screenshot \u2014 Full Program Execution <p>Shows the complete execution flow, including: - File reading - Demand score calculation - Writing results - Running all sorting algorithms  </p> <p></p>"},{"location":"appendix/run-screenshots/#3-results-summary","title":"3. Results Summary","text":"View Screenshot \u2014 Runtime Summary <p>Summarizes measured runtimes of all sorting algorithms.</p> <p></p>"},{"location":"appendix/run-screenshots/#4-reading-writing-stage","title":"4. Reading &amp; Writing Stage","text":"View Screenshot \u2014 Reading and Writing Runtime <p>Demonstrates runtime measurement for file input and output operations.</p> <p></p>"},{"location":"appendix/run-screenshots/#5-demand-score-processing-stage","title":"5. Demand Score Processing Stage","text":"View Screenshot \u2014 Demand Score Computation Runtime <p>Illustrates time required for computing demand scores.</p> <p></p>"},{"location":"appendix/run-screenshots/#6-sorting-algorithms-runtime-comparison","title":"6. Sorting Algorithms Runtime Comparison","text":""},{"location":"appendix/run-screenshots/#selection-sort","title":"Selection Sort","text":"View Screenshot \u2014 Selection Sort Runtime"},{"location":"appendix/run-screenshots/#insertion-sort","title":"Insertion Sort","text":"View Screenshot \u2014 Insertion Sort Runtime"},{"location":"appendix/run-screenshots/#merge-sort","title":"Merge Sort","text":"View Screenshot \u2014 Merge Sort Runtime"},{"location":"appendix/run-screenshots/#quick-sort","title":"Quick Sort","text":"View Screenshot \u2014 Quick Sort Runtime"},{"location":"appendix/run-screenshots/#validation-summary","title":"Validation Summary","text":"<p>These screenshots confirm:</p> <ul> <li>Successful validation and loading of 3432 records </li> <li>Correct demand score computation  </li> <li>Accurate sorting using four algorithms  </li> <li>Reliable runtime measurement and benchmarking  </li> </ul> <p>The results demonstrate correctness of implementation and consistency between theoretical expectations and measured performance.</p>"},{"location":"overview/design-overview/","title":"High-Level Solution / System Design Overview","text":"<p>The system analyzes student course registration data to compute course demand using efficient data structures and sorting algorithms. It follows a multi-phase workflow designed for correctness, traceability, and runtime efficiency.</p>"},{"location":"overview/design-overview/#system-overview","title":"System Overview","text":""},{"location":"overview/design-overview/#reading","title":"Reading","text":"<p>Purpose: Load and validate data from <code>Input.txt</code> Handled by: <code>FileService.java</code>, <code>InputValidator.java</code></p> <p>Input format: <code>studentID;courseID;academicLevel;regTime</code></p> <p>Output: Valid <code>Registration</code> objects stored in a custom linked list</p>"},{"location":"overview/design-overview/#processing","title":"Processing","text":"<p>Purpose: Compute a demand score for each registration Handled by: <code>DemandScorer.java</code></p> <p>Output: Each linked-list node enriched with a demand score</p>"},{"location":"overview/design-overview/#writing","title":"Writing","text":"<p>Purpose: Export processed data before sorting Handled by: <code>FileService.java</code></p> <p>Output file: <code>Output.txt</code> (same format + demand score)</p>"},{"location":"overview/design-overview/#sorting-benchmarking","title":"Sorting &amp; Benchmarking","text":"<p>Purpose: Sort registrations by demand score and compare runtimes Handled by: <code>SelectionSort.java</code>, <code>InsertionSort.java</code>, <code>MergeSort.java</code>, <code>QuickSort.java</code>, <code>Benchmarker.java</code> / <code>Timer.java</code></p> <p>Outputs: Sorted result files per algorithm + runtime comparison</p>"},{"location":"overview/design-overview/#phase-1-reading","title":"Phase 1 \u2014 Reading","text":"<p>Purpose: Load and validate data from <code>Input.txt</code> Handled by: <code>FileService.java</code> and <code>InputValidator.java</code></p>"},{"location":"overview/design-overview/#input-handling","title":"Input Handling","text":"<p>Reads student registration records in the format: <code>studentID;courseID;academicLevel;regTime</code></p>"},{"location":"overview/design-overview/#validation","title":"Validation","text":"<p>Ensures data validity and skips incorrect or incomplete entries.</p>"},{"location":"overview/design-overview/#storage","title":"Storage","text":"<p>Stores validated entries as <code>Registration</code> objects in a custom linked list.</p>"},{"location":"overview/design-overview/#phase-2-processing","title":"Phase 2 \u2014 Processing","text":"<p>Purpose: Compute a demand score for each registration Handled by: <code>DemandScorer.java</code></p> <p>The final demand score is computed and stored inside each <code>Registration</code> node.</p>"},{"location":"overview/design-overview/#base-score","title":"Base Score","text":"<p>All registrations start with a base score of 50.</p>"},{"location":"overview/design-overview/#academic-level-multiplier","title":"Academic Level Multiplier","text":"<ul> <li>Freshman \u2192 \u00d70.75  </li> <li>Sophomore \u2192 \u00d70.90  </li> <li>Junior \u2192 \u00d71.10  </li> <li>Senior \u2192 \u00d71.25  </li> <li>Graduate \u2192 \u00d71.50  </li> </ul>"},{"location":"overview/design-overview/#registration-time-factor","title":"Registration Time Factor","text":"<ul> <li>+10 points (8\u201310 AM)  </li> <li>+5 points (6\u20138 AM)  </li> <li>0 points (12\u20132 PM)  </li> <li>\u22125 to \u221215 points (late afternoon/evening)</li> </ul>"},{"location":"overview/design-overview/#course-id-priority","title":"Course ID Priority","text":"<ul> <li>Odd course codes \u2192 +20 points  </li> <li>Even course codes \u2192 \u221210 points  </li> </ul>"},{"location":"overview/design-overview/#phase-3-writing","title":"Phase 3 \u2014 Writing","text":"<p>Purpose: Export processed data to a text file before sorting Handled by: <code>FileService.java</code></p>"},{"location":"overview/design-overview/#conversion","title":"Conversion","text":"<p>Converts the linked list into an array of <code>Registration</code> objects for sorting.</p>"},{"location":"overview/design-overview/#output","title":"Output","text":"<p>Writes processed records to <code>Output.txt</code> in the same format, including demand scores.</p>"},{"location":"overview/design-overview/#phase-4-sorting-and-benchmarking","title":"Phase 4 \u2014 Sorting and Benchmarking","text":"<p>Purpose: Sort by demand score and measure execution time Handled by: Sorting and benchmarking classes</p>"},{"location":"overview/design-overview/#sorting-algorithms","title":"Sorting Algorithms","text":"<ul> <li><code>SelectionSort.java</code> </li> <li><code>InsertionSort.java</code> </li> <li><code>MergeSort.java</code> </li> <li><code>QuickSort.java</code></li> </ul>"},{"location":"overview/design-overview/#benchmarking","title":"Benchmarking","text":"<p>Measures and compares runtime using a benchmark utility (<code>Benchmarker.java</code> / <code>Timer.java</code>).</p>"},{"location":"overview/design-overview/#sorted-outputs","title":"Sorted Outputs","text":"<p>Exports sorted results to:</p> <ul> <li><code>Sorted_Output_SS.txt</code> </li> <li><code>Sorted_Output_IS.txt</code> </li> <li><code>Sorted_Output_MS.txt</code> </li> <li><code>Sorted_Output_QS.txt</code></li> </ul>"},{"location":"overview/design-overview/#flow-of-execution","title":"Flow of Execution","text":"<p>The complete program flow is illustrated in the system flowchart below:</p> Diagram <p></p>"},{"location":"overview/introduction/","title":"Introduction","text":"<p>Sorting algorithms are fundamental to computer science and play a critical role in organizing, processing, and retrieving data efficiently. They form the backbone of numerous applications, including databases, scheduling systems, analytics platforms, and search operations.</p> <p>The efficiency of a system often depends on how effectively it can sort and structure its data. Understanding algorithmic behavior and performance characteristics is essential for building scalable and optimized solutions.</p>"},{"location":"overview/introduction/#background","title":"Background","text":"<p>Sorting improves data accessibility and simplifies operations such as searching, merging, and filtering. Different algorithms offer distinct trade-offs in:</p> <ul> <li>Time complexity  </li> <li>Space complexity  </li> <li>Implementation simplicity  </li> <li>Stability and scalability  </li> </ul> <p>Algorithms such as Selection Sort, Insertion Sort, Merge Sort, and Quick Sort illustrate how design decisions affect runtime and memory.</p>"},{"location":"overview/introduction/#problem-statement","title":"Problem Statement","text":"<p>This project compares the performance of four sorting algorithms through theoretical complexity analysis and empirical runtime measurement under a controlled environment.</p> <p>All methods are implemented using the same dataset to ensure a fair comparison. The dataset consists of student registration records, enabling a realistic academic use case such as identifying course demand trends.</p> <p>Key question: Which algorithm performs best as input size increases?</p>"},{"location":"overview/introduction/#scope-of-work","title":"Scope of Work","text":""},{"location":"overview/introduction/#data-structure","title":"Data Structure","text":"<ul> <li>Implement a custom Linked List to store registration records  </li> <li>Convert the list into an array for sorting  </li> </ul>"},{"location":"overview/introduction/#demand-computation","title":"Demand Computation","text":"<ul> <li>Compute a demand score per record  </li> <li>Use multiple weighted factors for scoring  </li> </ul>"},{"location":"overview/introduction/#sorting-algorithms","title":"Sorting Algorithms","text":"<p>Implement and apply:</p> <ul> <li>Selection Sort  </li> <li>Insertion Sort  </li> <li>Merge Sort  </li> <li>Quick Sort  </li> </ul>"},{"location":"overview/introduction/#performance-measurement","title":"Performance Measurement","text":"<ul> <li>Measure runtime for each algorithm  </li> <li>Compare results under consistent conditions  </li> <li>Interpret performance differences at scale  </li> </ul>"},{"location":"overview/introduction/#objective","title":"Objective","text":"<p>Evaluation Focus</p> <p>The comparison is performed using the same dataset and environment across all implementations to keep the results consistent and comparable.</p>"},{"location":"overview/introduction/#performance-understanding","title":"Performance Understanding","text":"<p>Explore the relationship between algorithmic design and runtime efficiency, especially under large-scale datasets.</p>"},{"location":"overview/introduction/#trade-off-analysis","title":"Trade-off Analysis","text":"<p>Evaluate practical trade-offs between simpler approaches and divide-and-conquer algorithms (time vs. space vs. implementation cost).</p>"},{"location":"overview/introduction/#empirical-validation","title":"Empirical Validation","text":"<p>Compare theoretical complexity expectations with measured runtimes to highlight real-world behavior.</p>"},{"location":"report/report/","title":"Project Report \u2014 Interactive Viewer","text":"<p>This page provides access to the complete project report in HTML format. You may preview it directly below or open it separately.</p>"},{"location":"report/report/#open-in-browser","title":"Open in Browser","text":"<p>View the full report in a separate tab for better navigation.</p> <p>Open Report in New Tab</p>"},{"location":"report/report/#download-copy","title":"Download Copy","text":"<p>Download the HTML report file directly to your device.</p> <p>Download Report</p>"},{"location":"report/report/#embedded-preview","title":"Embedded Preview","text":""},{"location":"teamwork/contributions/","title":"Teamwork Contribution &amp; Coordination","text":"<p>This project was completed collaboratively by Shoug Alomran and Layan Bindayel under the supervision of Dr. Najla Althuniyan.</p> <p>Throughout development, responsibilities were clearly divided while maintaining continuous communication to ensure integration consistency, correctness, and timely completion.</p>"},{"location":"teamwork/contributions/#role-distribution","title":"Role Distribution","text":""},{"location":"teamwork/contributions/#layan-bindayel","title":"Layan Bindayel","text":"<p>Project Organization &amp; Core Structure</p> <ul> <li>Managed overall coordination and task distribution  </li> <li>Designed the report template and structured documentation  </li> <li>Implemented foundational components:<ul> <li><code>Node.java</code></li> <li><code>LinkedList.java</code></li> <li><code>FileService.java</code></li> <li><code>Comparators.java</code></li> </ul> </li> <li>Authored:<ul> <li>High-Level Solution section  </li> <li>Asymptotic Performance Analysis section  </li> </ul> </li> </ul>"},{"location":"teamwork/contributions/#shoug-alomran","title":"Shoug Alomran","text":"<p>Runtime Analysis &amp; Algorithm Implementation</p> <ul> <li>Led analytical and benchmarking components  </li> <li>Implemented:<ul> <li><code>InputValidator.java</code></li> <li><code>DemandScorer.java</code></li> <li><code>SelectionSort.java</code></li> <li><code>InsertionSort.java</code></li> <li><code>MergeSort.java</code></li> <li><code>QuickSort.java</code></li> <li><code>Benchmarker.java</code></li> <li><code>Timer.java</code></li> </ul> </li> <li>Authored:<ul> <li>Runtime Measurement section  </li> <li>Performance tables and analysis  </li> </ul> </li> </ul>"},{"location":"teamwork/contributions/#joint-contribution","title":"Joint Contribution","text":"<p>Both members collaborated equally on:</p> <ul> <li><code>Main.java</code> \u2014 integration of all system components  </li> <li>System testing and debugging  </li> <li>Data validation and correctness verification  </li> <li>Editing and refining the final project report  </li> </ul>"},{"location":"teamwork/contributions/#team-reflection","title":"Team Reflection","text":"<p>The collaboration combined strong structural organization and analytical depth, resulting in a system that is both technically accurate and well-documented.</p> <p>Clear task allocation, continuous review, and integration testing ensured that all components worked cohesively as a unified solution.</p>"}]}