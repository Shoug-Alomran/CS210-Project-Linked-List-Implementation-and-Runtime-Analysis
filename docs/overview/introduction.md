# Introduction

Sorting algorithms are a fundamental part of computer science and play a crucial role in data organization and efficiency. They determine how data is arranged, accessed, and analyzed, forming the backbone of many applications in databases, scheduling systems, and analytical software. Understanding how different sorting algorithms behave is key to developing optimized and scalable solutions.

---

## Background

Sorting enables faster data retrieval and better memory management. In data structures, sorting is often required to simplify operations such as searching, merging, and filtering.  
Different sorting algorithms—like Selection Sort, Insertion Sort, Merge Sort, and Quick Sort—offer various trade-offs between **simplicity**, **speed**, and **memory usage**. Studying and comparing their performance highlights how algorithmic design impacts runtime efficiency.

---

## Problem Statement

The project focuses on comparing the **performance of four sorting algorithms** by analyzing their theoretical and measured runtimes. It aims to determine which algorithm provides the best efficiency for large-scale datasets by implementing all four methods within a controlled environment using the same dataset.

By using student registration data as the input, the project demonstrates how sorting and demand calculation techniques can be applied to practical academic use cases, such as determining course demand trends.

---

## Scope of Work

This project includes:
- Implementing a **custom Linked List** data structure to store student registration data.
- Processing each record to compute a **demand score** using multiple weighted factors.
- Converting the linked list into an array for sorting.
- Applying four sorting algorithms:
  1. Selection Sort  
  2. Insertion Sort  
  3. Merge Sort  
  4. Quick Sort
- Measuring and comparing runtimes for each algorithm.
- Interpreting the results to evaluate which approach is most efficient.

---

## Objective

The objective of this project is to:
- Explore the relationship between **data structures**, **algorithmic design**, and **runtime performance**.
- Understand the practical trade-offs between simple and complex sorting techniques.
- Provide a measurable comparison of efficiency between algorithms in real-world data processing scenarios.