# Conclusion

The results of this project confirmed that the implemented algorithms performed as predicted, both theoretically and practically. Runtime analysis showed that **Merge Sort** and **Quick Sort** achieved the fastest execution times due to their **O(n log n)** complexity, while **Selection Sort** and **Insertion Sort** were slower, consistent with their **O(n²)** complexity. This alignment between theory and results demonstrates that the system’s implementation was accurate and effective.

---

## Lessons Learned

Through this project, the team gained a deeper understanding of the **trade-off between simplicity and efficiency**.  
Simple algorithms such as Selection and Insertion Sort are easier to implement and visualize but become impractical as data size increases. More advanced algorithms like Merge Sort and Quick Sort, though complex, provide significantly better performance for large datasets.  

This hands-on experience illustrated how algorithmic design choices directly impact program performance in real-world scenarios.

---

## Future Recommendations

For future improvements, the system could be extended to:
- Process **real-time registration data** directly from a university database.
- Include a **graphical interface** to visualize demand scores and sorted results.
- Add **automatic data validation** and input error detection.
- Explore additional algorithms such as **Heap Sort** or **Counting Sort** to compare broader performance trends.

Overall, the project successfully achieved its objectives—demonstrating how data structures, algorithmic design, and runtime performance intersect in practical software development.